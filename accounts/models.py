import datetime
import os
import re
import tldextract
import twitter

from countries.models import Country, UsState
from datetime import timedelta 

from django.conf import settings
from django.contrib.auth.models import User, UserManager
from django.contrib.contenttypes import generic
from django.contrib.contenttypes.models import ContentType
from django.contrib.sites.models import Site
from django.core.exceptions import ObjectDoesNotExist
from django.core.mail import mail_admins, EmailMultiAlternatives, EmailMessage, send_mail
from django.core.urlresolvers import reverse
from django.db import models, IntegrityError
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.template import Context
from django.template.loader import render_to_string
from django.utils.translation import ugettext_lazy as _

from easy_thumbnails.fields import ThumbnailerImageField
from itertools import chain
from operator import attrgetter
from support.models import AutoGeneratedEmail

from advancedmod.utils import ModelModerator, moderator
from utils.anti_spam import (
    check_post_for_spam_via_defensio, 
    SPAM_TERMS_PATTERN, 
    SPAM_TLDS_PATTERN
)

from eazyemail.models import EazyEmail

GENDER = (
    ('0', 'In-Between'),
    ('1', 'Male'),
    ('2', 'Female')
)

EDUCATION = (
    ('1', 'High-School'),
    ('2', 'Some College'),
    ('3', 'College Degree'),
    ('4', 'Masters Degree'),
    ('5', 'Doctoral Degree'),
    ('6', 'Other')
)

OCCUPATION = (
    ('1', 'Artist'),
    ('2', 'Arts Administrator'),
    ('3', 'Curator'),
    ('4', 'Gallerist/Art Dealer'),
    ('5', 'Academic/Educator'),
    ('6', 'Student'),
    ('7', 'Architect'),
    ('8', 'Creative Director/Producer'),
    ('9', 'Designer'),
    ('10', 'Writer/Editor'),
    ('11', 'IT Professional (Programmer, SysAdmin, etc)'),
    ('12', 'Sales'),
    ('13', 'Entrepreneur'),
    ('14', 'Executive/Manager'),
    ('15', 'Other'),
)

INDUSTRY = (
    ('1', 'New Media (Commercial)'),
    ('2', 'New Media Art'),
    ('3', 'Other Arts'),
    ('4', 'Legal'),
    ('5', 'Music'),
    ('6', 'Finance'),
    ('7', 'Architecture'),
    ('8', 'Communications/Media'),
    ('9', 'Entertainment'),
    ('10', 'Publishing'),
    ('11', 'Sciences'),
    ('12', 'Information Technology'),
    ('13', 'Other')
)

ADDRESS_TYPES = (
    ('billing', 'Billing'),
    ('shipping', 'Shipping')
)


def get_icon_upload_to(self, filename):
    current = RhizomeUser.objects.get(id=self.id)
    if current.icon != self.icon:
        if os.path.exists(current.icon.path):
            if "rhizome_user_default.png" not in current.icon.path:
                os.remove(current.icon.path)  
    extension = filename.split('.')[-1]
    #add check extension logic
    return 'accounts/images/icons/%s.%s' % (self.id,extension)

class MiniProfileChoice(models.Model):
    description = models.CharField(max_length=300)
    def __unicode__(self):
        return self.description

class RhizomeUser(User):
    from artbase.models import ArtworkStub
    """
    Profile for auth.user. Methods etc can be grabbed via user.get_profile(). 
    We're also inheriting from User. This could be bad, but seems like we have our cake and eat it too. NH
    """
    user = models.OneToOneField(User, null=False) 
    bio = models.TextField(null=True, blank=True)
    spam_question = models.CharField(max_length=255, verbose_name="What will you do with your new Rhizome account?")
    url = models.URLField(null=True, blank=True,db_index=True)
    timezone = models.CharField(max_length=50, default='US', null=True, blank=True)
    modified = models.DateTimeField(null=True, editable=False, auto_now=True)
    occupation = models.CharField(max_length=100, null=True, blank=True,choices=OCCUPATION) 
    industry = models.CharField(max_length=64, null=True, blank=True,choices=INDUSTRY) 
    facebook = models.CharField(_('FaceBook profile URL'),max_length=64, null=True, blank=True)
    twitter = models.CharField(_('Twitter handle'),max_length=64, null=True, blank=True)
    gender = models.CharField(max_length=6, blank=True,choices=GENDER, null=True)
    show_email = models.BooleanField()
    age = models.IntegerField(max_length=4, null=True, blank=True)
    visible = models.BooleanField(_('Make Profile Visible?'), blank=True, db_index=True, default=True)
    education = models.CharField(max_length=10, null=True, blank=True, choices=EDUCATION)
    icon = ThumbnailerImageField(upload_to = get_icon_upload_to,resize_source=dict(size=(50, 50), crop='smart'), null=True, blank=True, default = "accounts/images/icons/rhizome_user_default.png", db_index=True)
    description = models.CharField(max_length=256, null=True, blank=True)
    miniprofile_choices = models.ManyToManyField(MiniProfileChoice,null=True, blank=True)
    registration_code = models.CharField(max_length=25,null=True,blank=True)
    saved_artworks = models.ManyToManyField(ArtworkStub,null=True,blank=True)

    class Meta:
        verbose_name = _('Profile')
        verbose_name_plural = _('Profiles')
    
    def __unicode__(self):
        if self.first_name and self.last_name:
            return '%s' % self.get_full_name()
        elif self.first_name:
            return '%s' % self.first_name
        else:
            return '%s' % (self.username)
        
    def save(self, *args, **kwargs):
        ''' On save, update timestamps '''
        if not self.pk:
            self.created = datetime.datetime.now()


        self.modified = datetime.datetime.now()
        self.username = self.username.replace(" ","_")

        super(RhizomeUser, self).save(*args, **kwargs)

    # Use UserManager to get the create_user method, etc.
    objects = UserManager()
    
    ##deprecated, should be removed if not used anywhere on site
    def full_name(self): 
        full_name =  u'%s %s' % (self.user.first_name, self.user.last_name)        
        return full_name.title()
       
    def get_web_links(self):
        '''
        returns a user's external url, facebook page, skyp, twitter, etc
        '''
        d = {"website":self.url,"facebook":self.facebook,"twitter":self.twitter}
        web_links = [d]
        return web_links
        
    def has_icon(self):
        if self.icon and os.path.exists(self.icon.path):
            if self.icon != 'accounts/images/icons/rhizome_user_default.png':
                return True
        return False

    def address(self, address_type=None):
        address = ''
        if address_type:
            try:
                address_list =  UserAddress.objects.filter(user = self, address_type = address_type ).order_by("-pk")[:1]
                for a in address_list:
                    address = a
            except:
                None     
        else:
            try:
                address_list =  UserAddress.objects.filter(user = self).order_by("-pk")[:1]
                for a in address_list:
                    address = a
            except:
                address = None

        return address
        
    def get_shipping_address(self):
        address_list =  UserAddress.objects.filter(user = self, address_type = "shipping").order_by("-created")[:1]
        for a in address_list:
            return a

    def get_billing_address(self):
        address_list =  UserAddress.objects.filter(user = self, address_type = "billing").order_by("-created")[:1]
        for a in address_list:
            return a

    def make_member(self,donation):
        try:
            membership = RhizomeMembership.objects.get(user=self)
        except RhizomeMembership.DoesNotExist:
            membership = RhizomeMembership(user=self)
            
        membership.member_tools = True 
        membership.archival_access = True 
        membership.member_tools_exp_date = donation.created + timedelta(days=365)        
        membership.archival_access_exp_date = donation.created + timedelta(days=365)
        membership.save()
        return membership

    def make_complimentary_member(self):
        try:
            membership = RhizomeMembership.objects.get(user=self)
        except:
            membership = RhizomeMembership(user=self)
        membership.complimentary = True 
        membership.member_tools = True 
        membership.archival_access = True 
        membership.save()
        return membership
        
    def make_orgsub_member(self,orgsub):
        try:
            membership = RhizomeMembership.objects.get(user=self)
        except:
            membership = RhizomeMembership(user=self)
        if orgsub.active == True:
            membership.archival_access = True 
            membership.member_tools = True 
            membership.archival_access_exp_date = orgsub.expiration_date
            membership.member_tools_exp_date = orgsub.expiration_date
            membership.org_sub = orgsub
            membership.save()
        else:
            membership.org_sub = orgsub
            membership.save()        
    
    def get_rating(self):
        if not self.pk:
            return 0
        try:
            rating = UserRating.objects.get(user=self)
            return int(rating.rating)
        except UserRating.DoesNotExist:
            rating = UserRating(user=self, rating=0)
            rating.save()
            return int(rating.rating)
        
    get_rating.short_description = 'Rating'
    get_rating.admin_order_field = 'user_rating'
    
    def get_rating_object(self):
        try:
            return UserRating.objects.get(user=self)
        except UserRating.DoesNotExist:
            rating = UserRating(user=self, rating=0)
            rating.save()
            return rating
            
    def add_points(self, points):
        rating = self.get_rating_object()
        rating.rating = rating.rating + points
        rating.save()
    
    def add_points_for_object(self, content_object):
        rating = self.get_rating_object()
        user_points = rating.rating
        object_points = 0
        
        content_type =  ContentType.objects.get_for_model(content_object.__class__)
        two_points = ["announce","Threaded comment","comment","resources","discuss"]
        three_points = ["artbase","Proposal"]
        five_points = ["post"]
                
        if "%s" % content_type.name in two_points or "%s" % content_type.app_label in two_points:
            object_points = 2
            user_points = user_points + 2
        if "%s" % content_type.name in three_points or "%s" % content_type.app_label in three_points:
            object_points = 3
            user_points = user_points + 3
        if "%s" % content_type.name in five_points or "%s" % content_type.app_label in five_points:
            object_points = 5
            user_points = user_points + 5
        if "%s" % content_type.name == "artwork stub":
            if content_object.status == "approved":        
                object_points = 10
                user_points = user_points + 10
                    
        # check to see if object previously published by 
        # looking it up in UserObjectPoints, if not create and give points
        points_object, created = UserObjectPoints.objects.get_or_create(user=self, \
                content_type = content_type, object_pk = content_object.id,points=object_points)
                
        if created: 
            rating.rating = user_points
            rating.save()
        else:
            #no points
            pass
            
    def membership(self):
        '''
        returns the membership if user if it exists
        '''
        try:
            membership =  RhizomeMembership.objects.get(user = self.id)
        except:
            membership = False      
            
        return membership
        
    def is_rhizomemember(self):  #CLEAN OUT THIS DUPLICATE
        return self.is_member()
    
    def is_member(self):
        try:
            membership = RhizomeMembership.objects.get(user=self.id)
            if membership.member_tools == 1:
                return True
        except RhizomeMembership.DoesNotExist:
            pass

        return False 
    is_member.short_description = 'member'
    is_member.boolean = True            

    def is_new_user(self):
        #has user account been created in last two days?
        cutoff_date = (datetime.datetime.today() - timedelta(3))
        if self.date_joined > cutoff_date:
            return True
        else:
            return False

    def is_recent_user(self):
        cutoff_date = datetime.datetime.strptime("01 08 2012", "%d %m %Y")
        if self.date_joined > cutoff_date:
            return True
        else:
            return False


    def is_old_school(self):
        #has user account older than 5 years?
        cutoff_date = (datetime.datetime.today() - datetime.timedelta(365*5))
        if self.date_joined < cutoff_date:
            if self.date_joined.year == int("1996"):
                return "the beginning"
            else:
                return self.date_joined.strftime("%Y")
        else:
            return False

    def get_membership(self): #CLEAN OUT THIS DUPLICATE
        '''
        true or false on whether a user is a member
        '''
        try:
            membership =  RhizomeMembership.objects.get(user = self.id)
            if membership:
                return membership
        except:
            return False 

    
    def org_sub_admin(self):
        try:
            rhizomemember =  RhizomeMembership.objects.get(user = self.id)
            if rhizomemember.org_sub_admin:
                return True
        except:
            return False      
    
    def orgsub(self):
        try:
            rhizomemember =  RhizomeMembership.objects.get(user = self.id)
        except RhizomeMembership.DoesNotExist:
            rhizomemember = None
        
        if rhizomemember:
            try:
                return rhizomemember.org_sub
            except ObjectDoesNotExist:
                return None
        else:
            return None

    def get_all_donations(self):
        from support.models import NewDonation
        return NewDonation.objects.filter(user=self.user).order_by('-created')
    
    def get_days_till_membership_expires(self):
        '''
        returns the number of days before a user's membership will expire
        '''
        try:
            membership_exp_time =  RhizomeMembership.values_list("member_tools_exp_date",flat=True).filter(user = self.id)
            days_till_membership_expires = membership_exp_time - datetime.datetime.now()
            return days_till_membership_expires.days
        except:
            return False
    
    def soon_to_expire(self):
        '''
        returns true or false on whether a user's membership will expire in 30 days
        '''
        try:
            membership = RhizomeMembership.objects.get(user = self.id)
            days_till_membership_expires = membership.member_tools_exp_date - datetime.datetime.now()
            if days_till_membership_expires.days <= 30:
                return True
            else:
                return False
        except:
            return False
            
        def get_state(self):
            if self.state != None:
                try:
                    state = self.state
                except:
                    state = self.legacy_state   
            else:
                state = None
            return state
     
    def get_country(self):   
        if self.country  != None:
            try:
                country = self.country
            except:
                country = self.legacy_country 
        else:
            country = None
        return country    
    
    def get_saved_artworks(self):
        return self.saved_artworks.all()

    def get_portfolio(self):
        try:
            from artbase.models import ArtworkStub
            portfolio = ArtworkStub.objects.filter(user = self).exclude(status = "unsubmitted").exclude(status = "deleted").exclude(status = "approved")
        except:
            portfolio = None
        if not portfolio:
            portfolio = None
            count = None
        else:
            count = len(portfolio)
        d = {"portfolio":portfolio, "count":count} 
        return portfolio

    def get_artbase_portfolio(self):
        try:
            from artbase.models import ArtworkStub
            portfolio = ArtworkStub.objects.filter(user = self, status = "approved")
        except:
            portfolio = None
        if not portfolio:
            portfolio = None
            count = None
        else:
            count = len(portfolio)
        d = {"portfolio":portfolio, "count":count} 
        return portfolio
    
    def get_entire_portfolio(self):
        try:
            from artbase.models import ArtworkStub
            portfolio = ArtworkStub.objects.filter(user = self).exclude(status = "deleted")
        except:
            portfolio = None
        if not portfolio:
            portfolio = None
            count = None
        else:
            count = len(portfolio)
        d = {"portfolio":portfolio, "count":count} 
        return portfolio
       
    def get_absolute_url(self):
        return reverse('user_profile', args=[self.username])
        
    def get_member_exhibitions(self):
        '''
        returns a user's member exhibition
        '''
        from artbase.models import MemberExhibition
        exhibitions =  MemberExhibition.objects.filter(user=self).filter(live=True)
        if not exhibitions:
            exhibitions = None
        return exhibitions

    def get_all_member_exhibitions(self):
        '''
        returns a user's member exhibition
        '''
        from artbase.models import MemberExhibition
        exhibitions =  MemberExhibition.objects.filter(user=self)
        if not exhibitions:
            exhibitions = None
        return exhibitions
    
    def get_announce_opportunities(self,age=None):
        '''
        returns user's opportunities
        '''
        from announce.models import Opportunity
        opportunities =  Opportunity.objects.filter(user=self).filter(status=True).sort_by("-created")
        if not calls:
            opportunities = None
            count = None 
        else:
            count = len(opportunities)
        d = {"opportunities":opportunities, "count":count}
        return d
            
    def get_announce_events(self):
        '''
        returns user's event posts
        '''
        from announce.models import Event
        events =  Event.objects.filter(user=self).filter(status=True).sort_by("-created")
        
        if not events:
            events = None
            count = None
        else:
            count = len(events)
        d = {"events":events,"count":count}
        return d

    def get_announce_jobs(self,age=None):
        '''
        returns user's job posts
        '''
        from announce.models import Job
        jobs =  Job.objects.filter(user=self).filter(status=True).sort_by("-created")
        
        if not jobs:
            jobs = None
            count = None
        else:
            count = len(jobs)
        d = {"jobs":jobs, "count":count}        
        return d
        
    def get_recent_announcements(self):
        from announce.models import Opportunity
        from announce.models import Job
        from announce.models import Event

        opportunities = Opportunity.objects \
            .filter(user=self) \
            .filter(status=True) \
            .order_by("-created")

        events = Event.objects \
            .filter(user=self) \
            .filter(status=True) \
            .order_by("-created")

        jobs = Job.objects \
            .filter(user=self) \
            .filter(status=True) \
            .order_by("-created")

        # filter query results
        opportunities = [opportunity for opportunity in opportunities if opportunity.can_edit()]
        events = [event for event in events if event.can_edit()]
        jobs = [job for job in jobs if job.can_edit()]

        announcements = sorted(chain(events, opportunities, jobs), key=attrgetter('created'),reverse=True)
        return announcements

    def get_announcements(self):
        from announce.models import Opportunity
        from announce.models import Job
        from announce.models import Event
        now = datetime.datetime.now()
        opportunities = Opportunity.objects.filter(user=self).order_by("-created")
        events = Event.objects.filter(user=self).order_by("-created")
        jobs = Job.objects.filter(user=self).order_by("-created")
        announcements = sorted(chain(events, opportunities, jobs), key=attrgetter('created'),reverse=True)
        return announcements
    
    def get_comments(self):
        '''
        returns user's comments on rhizome
        '''
        from threadedcomments.models import ThreadedComment
        comments =  ThreadedComment.objects.filter(user=self).filter(is_visible=True)
        if not comments:
            comments = None
            count = None
        else:
            count = len(comments)
        d = {"comments":comments,"count":count}
        return d
    
    def get_blog_posts(self, limit = None):
        '''
        returns user's blog posts on rhizome
        '''
        from blog.models import Post
        if limit:
            posts = Post.objects.filter(authors__id = self.id).filter(status=2).order_by("-publish")[:limit]
        else:
            posts = Post.objects.filter(authors__id = self.id).filter(status=2).order_by("-publish")[:10]
        if not posts:
            posts = None
        return posts

    def get_blog_posts_for_profile(self):
        '''
        returns user's blog posts on rhizome
        '''
        from blog.models import Post
        return Post.objects.filter(authors__id = self.id).filter(status=2).order_by("-publish")

    def get_all_activity_stream(self):
        stream = ActivityStream.objects.filter(user = self.id).order_by("-created")
        filtered = []
        for item in stream:
            if item.content_type.name == "Threaded comment":
                if item.content_object and item.content_object.is_removed == False and item.content_object.is_public == True:
                    filtered.append(item)
            if item.content_type.name == "job" or item.content_type.name == "event" or item.content_type.name == "opportunity":
                if item.content_object and item.content_object.status == True:
                    filtered.append(item)
                          
        filtered = sorted(filtered,key=attrgetter('created'),reverse=True)        
        return filtered
    
    def get_activity_stream(self, limit = None):
        if not limit:
            limit = 10            
        stream = ActivityStream.objects.filter(user = self.id).order_by("-created")[:limit]
        limited = []
        for item in stream:
            limited.append(item)
            if len(limited) == limit:
                limited = sorted(limited,key=attrgetter('created'),reverse=True)
                return limited

        
    def get_activity_stream_counts(self,stream = None):
        if not stream:
            stream = self.get_all_activity_stream()
        events = [item for item in stream if item.content_type.name == "event"]
        opps = [item for item in stream if item.content_type.name == "opportunity"]
        jobs = [item for item in stream if item.content_type.name == "job"]
        comments = [item for item in stream if item.content_type.name == "Threaded comment"]
        d = { "events":len(events), "opportunities": len(opps), "jobs": len(jobs), "comments":len(comments) }
        return d          
        
    def get_twitter(self):
        '''
        returns user's latest twitter tweet
        '''
        twitter_conn = twitter.Api()
        if self.twitter:
            status = twitter_conn.GetUserTimeline(self.twitter)
            for s in status:
                return s.text
        else:
            return None
    
    def get_miniprofile_choices(self):
        return self.miniprofile_choices.all()
    
    def get_large_miniprofile(self):
        if self.icon != "accounts/images/icons/rhizome_user_default.png":
            icon_path = "%s%s" %(settings.MEDIA_URL,self.icon)
            profile_name = u"%s" % self
            output = '<div class="miniprofile" rel="'+unicode(self.username)+'"><div id="'+self.username+'-miniprofile"><a href="'+self.get_absolute_url()+'/"><img width = "50" height = "50" title = "'+profile_name+'" style="float:left;" src="'+icon_path+'"/></a></div></div>'
        else:
            output = ''
        return output 
            
    def get_medium_miniprofile(self, show_default=False):
        if show_default or self.icon != "accounts/images/icons/rhizome_user_default.png":
            icon_path = "%s%s" %(settings.MEDIA_URL,self.icon)
            profile_name = u"%s" % self
            output = '<div class="miniprofile" rel="'+unicode(self.username)+'"><div id="'+self.username+'-miniprofile"><a class="span-1" href="'+self.get_absolute_url()+'/"><img width = "35" height = "35" title = "'+profile_name+'" style="float:left;" src="'+icon_path+'"/></a></div></div>'
        else:
            output = ''        
        return output      

    def get_medium_miniprofile_include_default(self):
        icon_path = "%s%s" %(settings.MEDIA_URL,self.icon)
        profile_name = u"%s" % self
        output = '<div class="miniprofile" rel="'+unicode(self.username)+'"><div id="'+self.username+'-miniprofile"><a class="span-1" href="'+self.get_absolute_url()+'/"><img width = "35" height = "35" title = "'+profile_name+'" style="float:left;" src="'+icon_path+'"/></a></div></div>'
        return output

    def get_small_miniprofile(self, show_default=False):
        if show_default or self.icon != "accounts/images/icons/rhizome_user_default.png":
            profile_name = u"%s" % self
            icon_path = "%s%s" %(settings.MEDIA_URL,self.icon)
            output = '<div class="miniprofile" rel="'+unicode(self.username)+'"><div id="'+self.username+'-miniprofile"><a href="'+self.get_absolute_url()+'/"><img width = "25" height = "25" title = "'+profile_name+'" style="float:left;margin-top:-5px;padding-right:5px" src="'+icon_path+'"/></a></div></div>'
        else:
            output = ''    
        return output     

    @property
    def verification_url(self):
        return 'http://%s%s?email=%s&registration_code=%s' % (
            Site.objects.get_current().domain, 
            reverse('welcome'), 
            self.email, self.registration_code)

    def send_verification_email(self, amount=None):
        verification_url = self.verification_url
        title = 'Verification Email'

        if amount:
            title = 'Donation Verification Email'
            verification_url = 'https://%s%s?email=%s&registration_code=%s&next=%s?amount=%s' % (
                Site.objects.get_current().domain,
                reverse('login'),
                self.email, self.registration_code,
                reverse('confirm_donation'), amount)

        email = EazyEmail.objects.get(title=title)
        email.send(settings.MEMBERSHIP_GROUP_EMAIL, [self.email], extra_context={
            'verification_url': verification_url,
        })

    def send_welcome_email(self):
        welcome_email = EmailMultiAlternatives()
        welcome_email.to = [self.email]
        welcome_email.subject = render_to_string('accounts/emails/welcome_email_subject.txt') 

        d = {
            'email_body': AutoGeneratedEmail.objects.get(email_title = 'user_welcome_email').email_body
        }

        html_message = render_to_string('accounts/emails/welcome_email.html', d)
    
        welcome_email.body = render_to_string('accounts/emails/welcome_email.txt', d)
        welcome_email.attach_alternative(html_message, 'text/html')
        welcome_email.send(fail_silently=False)

    def profile_may_contain_links(self):
        if self.url or self.facebook or self.twitter:
            return True

        if self.bio:
            if '[ur=' in self.bio:
                return True

            if 'www' in self.bio:
                return True

            if 'http' in self.bio:
                return True

        return False

    def is_trusted(self):
        if self.is_member(): 
            return True 

        if self.get_rating() > settings.MODERATION_CUTOFF_RATING:
            return True
        return False 

######
#### END RHIZOMEUSER 
#######

class RhizomeUserModerator(ModelModerator):
    def requires_moderation(self, user):
        # inactive users pass
        if not user.is_active:
            return False

        # anonymous users pass
        if not user.visible: 
            return False

        # trusted users pass 
        if user.is_trusted():
            return False

        # users with no links pass 
        if not user.profile_may_contain_links():
            return False
        return True

    def auto_detect_spam(self, user):
        if user.url:
            m = re.search(SPAM_TLDS_PATTERN, user.url)
            if m:
                return (True, 'url contains "%s"' % m.string[m.start():m.end()])

        if user.bio:
            m = re.search(SPAM_TERMS_PATTERN, user.bio)
            if m:
                return (True, 'bio contains "%s"' % m.string[m.start():m.end()])

        if user.url:
            m = re.search(SPAM_TERMS_PATTERN, user.url)
            if m:
                return (True, 'url contains "%s"' % m.string[m.start():m.end()])

        # doing this last to avoid unnecessary wait
        if user.bio: 
            if check_post_for_spam_via_defensio(user.bio):
                return (True, '')
        return (False, '')

    def moderation_queued(self, user):
        user.visible = False

    def moderation_fail(self, user, request):
        user.is_active = False
        user.visible = False

    def moderation_pass(self, user, request):
        user.visible = True 
        user.add_points(3)
        send_mail('Content Approved', self.approved_message_text(user), settings.DEFAULT_FROM_EMAIL, [user.email])

    def approved_message_text(self, user):
        return u'%s, your profile has been approved by our moderators.\n\nhttp://%s%s' % (
            user.get_profile(),
            Site.objects.get_current().domain,
            user.get_profile().get_absolute_url()
        )

    def spam_message_text(self, user):
        return 'We\'re sorry, but your profile did not pass our spam filter.'

    def queued_message_text(self, user):
        return 'Your profile has been sent to our staff for moderation.'

    def admin_info(self, user):
        return (
            ('username', user.username),
            ('email', user.email),
            ('url', '<a target="_blank" href="%s">%s</a>' % (user.url, user.url)),
            ('first', user.first_name),
            ('last', user.last_name),
            ('bio', user.bio),
            ('facebook', user.facebook),
            ('twitter', user.twitter),
            ('intent', user.spam_question)
        ) 
moderator.register(RhizomeUser, RhizomeUserModerator)

class UserRating(models.Model):
    '''
    Simple class for assigning values to users. Used in moderation of user-generated content. 
    The lower the rating, the higher the chances that user is spammer or needs to be moderated. 
    Pretty much a one-to-one relationship in terms of how many 
    public/moderated postings they have on the site. 
    If they spam site, many points are taken off.
    '''
    user = models.OneToOneField(User, related_name='user_rating')
    rating = models.IntegerField(max_length = 11, db_index = True) 

class UserObjectPoints(models.Model):
    '''
    Very similar to activity stream, except logs points for users activity. 
    I created this separately from activity stream as they seemed like 
    ultimately two different things in nature, and should be independent 
    as I figured we might need to check for user-to-object points in 
    tandem with activities. 
    '''
    created = models.DateTimeField(editable=False) 
    content_type   = models.ForeignKey(ContentType,verbose_name=_('content type'),related_name="content_type_set_for_%(class)s")
    object_pk = models.IntegerField(max_length = 11, db_index = True)    
    content_object = generic.GenericForeignKey(ct_field="content_type", fk_field="object_pk") 
    user = models.ForeignKey(User) 
    points = models.IntegerField(max_length = 11, db_index = True)
    
    def save(self, *args, **kwargs):
        ''' On save, update timestamps '''
        if not self.id:
            self.created = datetime.datetime.now()
        super(UserObjectPoints, self).save(*args, **kwargs)
    
    def get_content_object_url(self):
        """
        Get a URL suitable for redirecting to the content object.
        """
        return reverse(
            'comments-url-redirect', args=(self.content_type_id, self.object_pk)
        )

class ActivityStream(models.Model):
    '''
    tracks user's activity on site, comments, announcements, etc
    '''
    created = models.DateTimeField(editable=False) 
    content_type   = models.ForeignKey(ContentType,verbose_name=_('content type'),related_name="content_type_set_for_%(class)s")
    object_pk = models.IntegerField(max_length = 11, db_index = True)    
    content_object = generic.GenericForeignKey(ct_field="content_type", fk_field="object_pk") 
    user = models.ForeignKey(User) 
    
    def save(self, *args, **kwargs):
        ''' On save, update timestamps '''
        if not self.id:
            self.created = datetime.datetime.now()
        super(ActivityStream, self).save(*args, **kwargs)
    
    def get_content_object_url(self):
        """
        Get a URL suitable for redirecting to the content object.
        """
        return reverse(
            'comments-url-redirect', args=(self.content_type_id, self.object_pk)
        )

class UserAddress(models.Model):
    user = models.ForeignKey(User, null=False)
    address_type = models.CharField(choices = ADDRESS_TYPES, null=False, max_length = 15,  db_index = True)
    street1 = models.CharField(max_length=50, null=False)
    street2 = models.CharField(max_length=50, null=True,blank=True)
    city = models.CharField(max_length=75, null=False)
    state = models.ForeignKey(UsState, to_field='name',null=True,blank=True) 
    locality_province = models.CharField(max_length=100, null=True,blank=True)
    zip_postal_code = models.CharField(max_length=15, null=True,blank=True)
    country = models.ForeignKey(Country,null=False)    
    created = models.DateTimeField(editable=False) 
    
    def __unicode__(self):
        return "Address for %s" % (self.user.get_profile())

    def save(self, *args, **kwargs):
        if not self.id:
            self.created = datetime.datetime.now()
        super(UserAddress, self).save(*args, **kwargs)

    def get_user(self):
        user =  User.objects.get(id = self.user_id)
        return user
    
    def to_dict(self):
        address = {
            "address_type": self.address_type,
            "street1": self.street1,
            "street2": self.street2,
            "city": self.city,
            "locality_province": self.locality_province,
            "zip_postal_code": self.zip_postal_code,
        }
        
        try:
            address["state"] = self.state.name
        except:
            pass

        try:
            address["country"] = self.country.iso
        except:
            pass
    
        return address


    get_user.short_description = 'User'


class RhizomeMembership(models.Model): 
    from orgsubs.models import Organization
    from support.models import NewDonation
    
    user = models.OneToOneField(User, null=False,related_name='user_membership')
    complimentary = models.BooleanField()
    last_reminder_email = models.DateTimeField(null=True, blank=True)
    last_homecoming_email = models.DateTimeField(null=True, blank=True)
    complimentary_exp_date = models.DateTimeField(null=True, blank=True)
    org_sub = models.ForeignKey(Organization, null=True, blank=True) 
    org_sub_admin = models.BooleanField(default=False,db_index = True)
    archival_access = models.BooleanField(db_index = True)
    member_tools = models.BooleanField(db_index = True)
    archival_access_exp_date = models.DateTimeField(null=True)
    member_tools_exp_date = models.DateTimeField(null=True,db_index = True)
    email_confirmed = models.IntegerField(max_length=4, null=True, blank=True)
    modified = models.DateTimeField(null=True, editable=False, auto_now=True)
    created = models.DateTimeField(null=True, editable=False)
    
    def get_user(self):
        user = User.objects.get(id = self.user_id)
        return user
    
    get_user.short_description = 'User'
    
    def __unicode__(self):
        return '%s' % (self.user.get_profile())
    
    def is_rhizomemember(self):
        if self.member_tools == 1 or self.complimentary == 1:
            return True
        else: 
            return False         
                    
    def save(self, *args, **kwargs):
        ''' On save, update timestamps '''
        if not self.id:
            self.created = datetime.datetime.now()
        
        if not self.archival_access_exp_date:
            self.archival_access_exp_date = datetime.datetime.now()
        if not self.member_tools_exp_date:
            self.member_tools_exp_date = datetime.datetime.now()
        
        if self.archival_access_exp_date <= datetime.datetime.now():
            self.archival_access = 0
        if self.member_tools_exp_date <= datetime.datetime.now():
            self.member_tools = 0            
        
        if self.complimentary == 1:
            self.member_tools = 1
            self.archival_access = 1
            from orgsubs.models import Organization
            rhizome = Organization.objects.get(name="Rhizome")
            self.org_sub = rhizome
            self.member_tools_exp_date = rhizome.expiration_date
            self.archival_access_exp_date = rhizome.expiration_date
        
        self.modified = datetime.datetime.now()
        super(RhizomeMembership, self).save(*args, **kwargs)
    
    def get_days_till_membership_expires(self):
        days_till_membership_expires = datetime.datetime.now() - member_tools_exp_date
        return days_till_membership_expires
    
    ####
    # Many of these methods are duplicates from rhiozmeuser as they were added early on adhoc. They should be cleaned out or merged
    #####
    def make_orgsub_member(self,orgsub):
        if orgsub.active == True:
            self.archival_access = 1
            self.member_tools = 1
            self.archival_access_exp_date = orgsub.expiration_date
            self.member_tools_exp_date = orgsub.expiration_date
            self.org_sub = orgsub
            self.save()
        else:
            self.org_sub = orgsub
            self.save()

    def make_complimentary(self,expiration_date=None):
        self.complimentary = 1
        self.archival_access = 1
        self.member_tools = 1
        from orgsubs.models import Organization
        rhizome = Organization.objects.get(name="Rhizome")
        self.org_sub = rhizome
        self.member_tools_exp_date = rhizome.expiration_date
        self.archival_access_exp_date = rhizome.expiration_date
        self.save()
        
    def update_membership(self, donation = None, expiration_date=None):
        #takes a optional donation object and/or a manual expiration date
        self.archival_access = 1
        self.member_tools = 1
        
        if donation:
            donation_date_plus_one_year = donation.created + timedelta(days=365)

            if self.member_tools_exp_date:
                
                membership_plus_one_year = self.member_tools_exp_date + timedelta(days=365)
                
                if donation_date_plus_one_year > membership_plus_one_year:
                    self.archival_access_exp_date = donation_date_plus_one_year
                    self.member_tools_exp_date = donation_date_plus_one_year
                else:
                    self.archival_access_exp_date = membership_plus_one_year
                    self.member_tools_exp_date = membership_plus_one_year
            else:
                self.archival_access_exp_date = donation_date_plus_one_year
                self.member_tools_exp_date = donation_date_plus_one_year
                            
        if expiration_date:
            self.archival_access_exp_date = expiration_date
            self.member_tools_exp_date = expiration_date
        
        if not donation and not expiration_date:
            self.archival_access_exp_date = datetime.datetime.now() + timedelta(days=365)
            self.member_tools_exp_date = datetime.datetime.now() + timedelta(days=365)
        
        #10 points for renewing!
        self.user.get_profile().add_points(10)
        
        self.save()
    
    def remove_membership(self):
        self.archival_access = 0
        self.member_tools = 0   
        self.complimentary = 0
        self.member_tools_exp_date = datetime.datetime.now()
        self.archival_access_exp_date = datetime.datetime.now()
        self.save()
            
            
'''
Below are methods for the various models above
'''

def get_recently_updated_members_with_icons(search_limit,return_limit):
    '''
    returns members who have icons for displaying on frontpage
    '''
    recently_updated = RhizomeUser.objects.all().order_by("-modified").filter(visible=True)[:search_limit]
    members_with_icons = []
    append =  members_with_icons.append
    for user in recently_updated:
        if user.is_rhizomemember() == True:
            if user.icon != "accounts/images/icons/rhizome_user_default.png" and user.icon != '' and user.icon != None:
                append(user)
            else:
                pass  
            if len(members_with_icons) == return_limit:
                return members_with_icons
                
def get_recently_updated_portfolios(limit=None):
    from artbase.models import ArtworkStub

    if limit:
        return ArtworkStub.objects \
                .exclude(status = "unsubmitted") \
                .exclude(status = "approved") \
                .exclude(status = "deleted") \
                .exclude(image_small ="artbase/images/rhizome_art_default.png") \
                .order_by("-modified")[:limit]
    else:
        return ArtworkStub.objects \
                .exclude(status = "unsubmitted") \
                .exclude(status = "approved") \
                .exclude(status = "deleted") \
                .exclude(image_small ="artbase/images/rhizome_art_default.png") \
                .order_by("-modified")   

# signals
@receiver(post_save, sender=RhizomeUser, dispatch_uid='accounts.assign_points')
def assign_points(sender, instance, **kwargs):
    # don't use get or create so we can assign points to 0 if new
    try:
        rating = UserRating.objects.get(user=instance)
    except:
        rating = None
        
    if not rating:
        rating = UserRating.objects.create(user=instance,rating=0)
        rating.save()

from support.models import NewDonation

@receiver(post_save, sender=RhizomeUser, dispatch_uid='accounts.claim_membership')
def claim_membership(sender, instance, created, **kwargs):
    if created:
        donations = NewDonation.objects.filter(user__isnull=True, contact_email=instance.email)
        if donations:
            instance.get_profile().make_member(donations[0])
            donations[0].user = instance
            donations[0].save()
